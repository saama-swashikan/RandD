podTemplate(
    containers: [
        containerTemplate(
            name: 'sch-code-builder',
            image: '791532114280.dkr.ecr.us-east-1.amazonaws.com/sch-build-agent:sch-sit2-terragrunt',
            command: 'cat',
            ttyEnabled: true,
            resourceLimitEphemeralStorage: '10Gi',
            resourceLimitMemory: '16Gi'
        ),
        containerTemplate(
            name: 'sch-automapper',
            image: '791532114280.dkr.ecr.us-east-1.amazonaws.com/sch-build-agent:git',
            command: 'cat',
            ttyEnabled: true,
            resourceLimitEphemeralStorage: '5Gi',
            resourceLimitMemory: '8Gi'
        ),
        containerTemplate(
            name: 'sch-image-builder',
            image: '791532114280.dkr.ecr.us-east-1.amazonaws.com/sch-build-agent:kaniko-with-aws',
            command: 'cat',
            ttyEnabled: true,
            resourceLimitEphemeralStorage: '5Gi',
            resourceLimitMemory: '8Gi'
        ),
        containerTemplate(
            name: 'terragrunt-build',
            image: '791532114280.dkr.ecr.us-east-1.amazonaws.com/sch-build-agent:terragrunt-always-latest',
            command: 'cat',
            ttyEnabled: true,
            resourceLimitEphemeralStorage: '5Gi',
            resourceLimitMemory: '8Gi'
        ),
        containerTemplate(
            name: 'migration-script',
            image: '791532114280.dkr.ecr.us-east-1.amazonaws.com/sch-apps:migration-23r2',
            command: 'cat',
            ttyEnabled: true,
            resourceLimitEphemeralStorage: '5Gi',
            resourceLimitMemory: '8Gi'
        ),
        containerTemplate(
            name: 'sch-sanity-executor',
            image: '791532114280.dkr.ecr.us-east-1.amazonaws.com/sch-build-agent:sanity_git',
            command: 'cat',
            ttyEnabled: true,
            resourceLimitEphemeralStorage: '5Gi',
            resourceLimitMemory: '8Gi'
        ),
        containerTemplate(
            name: 'sch-code-builder-git',
            image: '791532114280.dkr.ecr.us-east-1.amazonaws.com/lsac-platform:ubuntu_4_gh',
            command: 'cat',
            ttyEnabled: true,
            resourceLimitEphemeralStorage: '5Gi',
            resourceLimitMemory: '4Gi'
        )
    ],
    volumes: [
        dynamicPVC(
            requestsSize : '500Gi',
            mountPath: '/var/lib/containers/storage/vfs'
        )
    ],
    envVars: [
        envVar(key: 'source_aws_account', value: '791532114280'),
        envVar(key: 'dest_aws_account', value: '791532114280'),
        envVar(key: 'source_aws_repo', value: 'dh-sit5'),
        envVar(key: 'dest_aws_repo', value: 'dh-sit5'),
        envVar(key: 'fnf_url', value: 'signin.sit5.lsacone.com'),
        envVar(key: 'dh_url', value: 'dh.sit5.lsacone.com'),
        envVar(key: 'grant_type', value: 'client_credentials'),
        envVar(key: 'client_id', value: 'data-onboarding'),
        envVar(key: 'vars_file_location', value: 'ansible/inventory/sch-sit2/host_vars/k8s-masters/vars'),
        envVar(key: 'otb_s3_bucket', value: 'dh-otb-sit5'),
        envVar(key: 'source_automapper_s3_bucket', value: 'lsac-dev-sch'),
        envVar(key: 'dh_s3_bucket', value: 'lsac-sit5-dh'),
        envVar(key: 'dh_uat_s3_bucket', value: 'lsac-sit5-dh-uat'),
        envVar(key: 'vars_location', value: 'sch-tf-envs/terragrunt/live/lsacone-dev-sch-sit5'),
        envVar(key: 'cluster_name', value: 'lsac-sit5-dh'),
        envVar(key: 'master_namespace', value: 'dh-sit5'),
        envVar(key: 'git_user', value: 'comprehend-bot'),
        envVar(key: 'primary_tenant', value: 'dh-sit3'),
        envVar(key: 'sch_tf_envs_branch', value: 'feature/SRE-10177'),
        envVar(key: 'src_git_user', value: 'comprehend-jenkins'),
        envVar(key: 'dest_git_user', value: 'comprehend-jenkins'),
        envVar(key: 'automapper_src_repo', value: 'airflow-dags-lsac-sit3-dh'),
        envVar(key: 'automapper_dest_repo', value: 'airflow-dags-lsac-sit5-dh'),
        envVar(key: 'automapper_git_src_branch', value: 'main'),
        envVar(key: 'automapper_git_dest_branch', value: 'main'),
        envVar(key: 'ecr_role', value: 'Jenkins-ECR-Role'),
        envVar(key: 'terragrunt_role', value: 'LSACAdministratorsAccess'),
        envVar(key: 'src_region', value: 'us-east-1'),
        envVar(key: 'dest_region', value: 'us-east-1'),
        envVar(key: 'rds_prefix', value: 'lsac-sit5-dh')
    ]
) 
{
    properties([
        parameters([
            extendedChoice(name: 'Components', multiSelectDelimiter: ',', quoteValue: false, 
                           type: 'PT_CHECKBOX', 
                           description: 'Select the Component', 
                           visibleItemCount: 22,
                           groovyScript: '''
                return ['PreRequisites', 'ApiDB', 'Docs', 'Redis', 'Aws-Cli-Unzip', 'SysAdmin', 'StudyAdmin', 'Python', 'Pyspark', 'PdaGateway', 'Transform', 'TransformApi', 'RawThirdParty', 'PdaDb', 'DQ', 'PdaHome', 'PdaNotifications', 'StudyTransform', 'Scale', 'Automaps-Inference-Image', 'Outbound', 'TerragruntApply', 'RedisRestart', 'init-all-api-Trigger', 'AutoMapper', 'GlobalFiles','OTB','Automaps-Inference-S3-Upload','dh-sanity-checks']
           '''
            )
        ])
    ])
    node(POD_LABEL) {
        stage('Select Components') {
                container('sch-code-builder'){
                script {
                    def selectedComponents = params.Components.split(',')
                    echo "Selected components: ${selectedComponents.join(', ')}"
                    // You can add any common setup logic here
                }
            } 
        }
        stage('Read User Input') {
            container('sch-code-builder'){ 
                script {
                    // Access the selected components from the 'Components' parameter
                    def selectedComponents = params.Components.split(',')
                    // Load the remaining user input from a file
                    def uploadedFile = 'uploaded_file.txt'
                    def fileBase64 = input message: 'Please provide a file', parameters: [base64File('file')]
                    sh "set +x; echo '$fileBase64' | base64 -d > ./uploaded_file.txt"
                    sh 'export $(cat ./uploaded_file.txt)'
                    archiveArtifacts uploadedFile
                    sh 'ls -lah'
                    sh 'pwd'
                }
            }
        }
        stage('PreRequisites') {
            script {
                if (params.Components.contains('PreRequisites')) {
                    container('sch-code-builder-git'){
                        // Stage 1: Pull Docker image using AWS credentials
                        withAWS(role:env.terragrunt_role, roleAccount:env.dest_aws_account, region:env.dest_region) {  
                            withCredentials([string(credentialsId: 'comprehend-bot-github-token', variable: 'git_token')]) {
                                sh '''

aws sts get-caller-identity
aws eks update-kubeconfig --name $cluster_name --region $dest_region

                                set +x
                                echo "\033[1;4;37;31m [PREREQUISTIES CHECK] \033[0m"
                        
                            
                            
        
                            git clone --branch $sch_tf_envs_branch https://$git_user:$git_token@github.com/comprehend/sch-tf-envs.git

                                echo "####Ubuntu pod creation####"
                                podname="pre-requisites-${BUILD_NUMBER}"
                                namespace=prereq
                                source_loc=$(pwd)

                                ###Deleting the pod if exist
                                kubectl get pods -n $namespace | grep $podname | awk '{print $1}' && kubectl delete pod $podname -n $namespace || echo "$podname in $namespace namespace not exist"
                                ##Namespace creation####

                                
                                kubectl get namespace | grep "$namespace" || kubectl create ns $namespace

cat <<EOF | kubectl -n $namespace apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: $podname
  labels:
    app: $podname
spec:
  containers:
  - image: ubuntu:latest
    command:
      - "sleep"
      - "604800"
    imagePullPolicy: IfNotPresent
    name: $podname
  restartPolicy: Always
EOF

                                if [ $? -eq 0 ]
                                then	
                                    echo "waiting for $podname pod up"
                                    sleep 20
                                    
                                    kubectl get pods -n $namespace | grep $podname  
                                ## required packages installation
                                    kubectl exec -n $namespace $podname -- bash -c "apt update && apt install curl zip telnet -y "  > install.txt
                                    kubectl exec -n $namespace $podname -- bash -c "apt update && curl https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o awscliv2.zip && unzip awscliv2.zip && ./aws/install" >> install.txt

                                    filename=values-$env.yaml 

                                    MSK_endpoint=$(cat $vars_location/datahub-account-sit5/terragrunt.hcl | grep msk_kafka | sed -e "s|:9096| |g" |awk '{print $3}' | tr -d '"' | head -1)
                                    otb_s3_endpoint=$(cat $vars_location/datahub-master-sit5/terragrunt.hcl | grep s3_bucket_name  | awk '{print $3}' | grep otb)
                                    app_s3_endpoint=$(cat $vars_location/datahub-master-sit5/terragrunt.hcl | grep s3_bucket_name  | awk '{print $3}' | grep lsac)

                                    rm -rf values-$env.yaml && cd $source_loc
                        set +x

                                                       ###RDS connection check
                                    echo "###checking the  $RDS_endpoint connectivity from the POD######"
                                #copy the telnet file to the pod
echo $rds_prefix
                                    aws rds describe-db-instances --query "DBInstances[?contains(Endpoint.Address,'$rds_prefix')].[Endpoint,DBInstanceStatus]"
                                    aws rds describe-db-instances --query "DBInstances[?contains(Endpoint.Address,'$rds_prefix') && (DBInstanceStatus=='available' || DBInstanceStatus=='backing-up')].Endpoint.Address" --output text
endpoints=$(aws rds describe-db-instances --query "DBInstances[?contains(Endpoint.Address,'$rds_prefix') && DBInstanceStatus=='available'].Endpoint.Address" --output text || tr '[:space:]' '\n')

rds_port="5432"
for RDS_endpoint in $endpoints
do
case "$RDS_endpoint" in 
  *oracle*)
rds_port="1521"
    ;;
esac

                                    echo "Port number is ${rds_port}"
                                    echo "  echo -e '\\x1dclose\\x0d' | telnet $RDS_endpoint $rds_port" > rds_con.sh && chmod +x rds_con.sh
                                    kubectl cp rds_con.sh $podname:/home/ -n $namespace
                                    kubectl exec -n $namespace $podname -- bash -c './home/rds_con.sh' > rds.txt
                                    
                                    rds=$(cat rds.txt | grep "Connected" | awk '{print $1}')
                                    rds_stat="Connected"
                                    #[[ ! -z "$rds" ]] && echo "================::::::RDS($rds_host) connectivity enabled:::::::===================" && || echo "#####WARNING::::RDS connectivity not enabled#####"
                                    if [ X"$rds" = X"$rds_stat" ]
                                    then
                                        echo "#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:"
                                        echo "------RDS connectivity result"
                                        echo "yes" >> rds_1.txt
                                        cat rds.txt rds_1.txt
                                        echo "#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:"
                                    else
                                        echo "no" >> rds_1.txt
                                    fi
done


                            ###MSK connection check
                                    echo "###checking the  MSK_endpoint connectivity from the POD######"
                                #copy the telnet file to the pod
                                    #echo "timeout --signal=9 2 telnet $MSK_endpoint 9096" > msk_con.sh && chmod +x msk_con.sh
                                    echo "  echo -e '\\x1dclose\\x0d' | telnet $MSK_endpoint 9096" > msk_con.sh && chmod +x msk_con.sh
                                    kubectl cp msk_con.sh $podname:/home/ -n $namespace
                                    #kubectl exec -n $namespace $podname -- bash -c "chmod +x /home/msk_con.sh"
                                    kubectl exec -n $namespace $podname -- bash -c "/home/msk_con.sh" 2>1 > msk.txt

                                    msk=$(cat msk.txt | grep "Connected" | awk '{print $1}')
                                    msk_stat="Connected"
                                    #[[ ! -z "$msk" ]] && echo "================::::::MSK($SK_endpoint) connectivity enabled:::::::==================="  ||  echo "#####WARNING::::MSK connectivity not enabled#####" 
                                    if [ X"$msk" = X"$msk_stat" ]
                                    then
                                        echo "#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:"
                                        echo "yes" > msk_1.txt
                                        echo "------MSK connectivity result"
                                        cat msk.txt msk_1.txt
                                        echo "#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:"
                                    else
                                        echo "no" > msk_1.txt
                                    fi
                                    

                            ###EKS connection check
                                    echo "###checking the  EKS connectivity from the POD######"
                                    kubectl get pods -n ${master_namespace} --no-headers | grep Running | head -1 2>1 > eks.txt
                                    eks=$(cat eks.txt | grep "Running" | awk '{print $3}' )
                                    eks_stat="Running"
                                    #[[ ! -z "$eks" ]] && echo "================::::::EKS($cluster_name) connectivity enabled:::::::==================="  ||  echo "#####WARNING::::EKS connectivity not enabled#####" 
                                    if [ X"$eks" = X"$eks_stat" ]
                                    then
                                        echo "#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:"
                                        echo "yes" > eks_1.txt
                                        echo "------EKS connectivity result"
                                        cat eks.txt eks_1.txt
                                        echo "#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:"
                                    else
                                        echo "no" > eks_1.txt
                                    fi
                            ###OTB S3 connection check        
                                    echo "###checking the  S3 connectivity from the POD######"
                                    kubectl exec -n $namespace $podname -- bash -c "touch test.txt && aws s3 cp test.txt s3://$otb_s3_endpoint" > s3.txt
                                    s3=$(cat s3.txt | grep upload: | awk '{print $1}')
                                    s3_stat="upload:"
                                    #[[ ! -z "$s3" ]] && echo "================::::::S3 connectivity enabled:::::::==================="  ||  echo "#####WARNING::::S3 connectivity not enabled#####" 
                                    if [ X"$s3" = X"$s3_stat" ]
                                    then
                                        echo "#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:"
                                        echo "yes" > s3_1.txt
                                        echo "------S3 connectivity result"
                                        cat s3.txt s3_1.txt
                                        echo "#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:"
                                    else
                                        echo "no" >> s3_1.txt
                                    fi
                        set -x
                                fi
                                loc=$(pwd)
                                echo $loc > path.txt
     ###App S3 connection check        
                                    echo "###checking the  S3 connectivity from the POD######"
                                    kubectl exec -n $namespace $podname -- bash -c "touch test.txt && aws s3 cp test.txt s3://$app_s3_endpoint" > s3.txt
                                    s3=$(cat s3.txt | grep upload: | awk '{print $1}')
                                    s3_stat="upload:"
                                    #[[ ! -z "$s3" ]] && echo "================::::::S3 connectivity enabled:::::::==================="  ||  echo "#####WARNING::::S3 connectivity not enabled#####" 
                                    if [ X"$s3" = X"$s3_stat" ]
                                    then
                                        echo "#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:"
                                        echo "yes" > s3_2.txt
                                        echo "------S3 connectivity result"
                                        cat s3.txt s3_2.txt
                                        echo "#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:"
                                    else
                                        echo "no" >> s3_2.txt
                                    fi
                        set -x
                                
                                loc=$(pwd)
                                echo $loc > path.txt

                                ###Deleting the pod if exist
                                kubectl get pods -n $namespace | grep $podname | awk '{print $1}' && kubectl delete pod $podname -n $namespace || echo "$podname in $namespace namespace not exist"
                                    
                                echo "$(cat rds_1.txt) $(cat msk_1.txt) $(cat eks_1.txt) $(cat s3_1.txt)" > precheck_status.txt

                                '''
                            }
                        }
                    }
                }
            }
        }   
        stage('Pull and Push API DB image') {
            script {
                if (params.Components.contains('ApiDB')) {
                    container('sch-code-builder'){
                    // Stage 1: Pull Docker image using AWS credentials
                        withAWS(role:env.ecr_role, roleAccount:env.source_aws_account, region:env.src_region) { 
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)    
                                image=$api_db
                                aws ecr get-login-password --region ${src_region} | podman login --username AWS --password-stdin ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com
                                podman pull ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:$image  
                                podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image} ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new  
                            '''
                        }
                        withAWS(role:env.ecr_role, roleAccount:env.dest_aws_account, region:env.dest_region) {  
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)
                                image=$api_db
                                aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com
                                aws ecr describe-images --repository-name ${dest_aws_repo} --region ${dest_region}  > image_tag.txt
                                if grep -w $image image_tag.txt; 
                                then 
                                    export date=$(date +%Y_%m_%d-%H%M)
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman pull ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                    podman tag ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    aws ecr batch-delete-image --repository-name ${dest_aws_repo} --image-ids imageTag=$image
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                else
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image        
                                    podman image prune --all --force
                                fi     
                            '''
                        }  
                    }
                }
            }
        }         
        stage('Pull and Push Docs image') {
            script {
                if (params.Components.contains('Docs')) {
                    container('sch-code-builder'){
                    // Stage 1: Pull Docker image using AWS credentials
                        withAWS(role:env.ecr_role, roleAccount:env.source_aws_account, region:env.src_region) { 
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)    
                                image=$docs
                                aws ecr get-login-password --region ${src_region} | podman login --username AWS --password-stdin ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com
                                podman pull ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:$image  
                                podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image} ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new  
                            '''
                        }
                        withAWS(role:env.ecr_role, roleAccount:env.dest_aws_account, region:env.dest_region) {  
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)
                                image=$docs
                                aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com
                                aws ecr describe-images --repository-name ${dest_aws_repo} --region ${dest_region}  > image_tag.txt
                                if grep -w $image image_tag.txt; 
                                then 
                                    export date=$(date +%Y_%m_%d-%H%M)
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman pull ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                    podman tag ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    aws ecr batch-delete-image --repository-name ${dest_aws_repo} --image-ids imageTag=$image
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                else
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image        
                                    podman image prune --all --force
                                fi     
                            '''
                        } 
                    }
                }
            }
        }  
        stage('Pull and Push Redis image') {
            script {
                if (params.Components.contains('Redis')) {
                    container('sch-code-builder'){
                    // Stage 1: Pull Docker image using AWS credentials
                        withAWS(role:env.ecr_role, roleAccount:env.source_aws_account, region:env.src_region) { 
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)    
                                image=$redis
                                aws ecr get-login-password --region ${src_region} | podman login --username AWS --password-stdin ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com
                                podman pull ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:$image  
                                podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image} ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new  
                            '''
                        }
                        withAWS(role:env.ecr_role, roleAccount:env.dest_aws_account, region:env.dest_region) {  
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)
                                image=$redis
                                aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com
                                aws ecr describe-images --repository-name ${dest_aws_repo} --region ${dest_region}  > image_tag.txt
                                if grep -w $image image_tag.txt; 
                                then 
                                    export date=$(date +%Y_%m_%d-%H%M)
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman pull ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                    podman tag ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    aws ecr batch-delete-image --repository-name ${dest_aws_repo} --image-ids imageTag=$image
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                else
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image        
                                    podman image prune --all --force
                                fi     
                            '''
                        }
                    }
                }
            }
        }

        stage('Pull and Push AWS CLI Unzip image') {
            script {
                if (params.Components.contains('Aws-Cli-Unzip') && currentBuild.resultIsBetterOrEqualTo('SUCCESS')) {
                    container('sch-code-builder'){
                    // Stage 1: Pull Docker image using AWS credentials
                        withAWS(role:env.ecr_role, roleAccount:env.source_aws_account, region:env.src_region) { 
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)    
                                image=$aws_cli_unzip_image
                                aws ecr get-login-password --region ${src_region} | podman login --username AWS --password-stdin ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com
                                podman pull ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:$image  
                                podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image} ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new  
                            '''
                        }
                        withAWS(role:env.ecr_role, roleAccount:env.dest_aws_account, region:env.dest_region) {  
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)
                                image=$aws_cli_unzip_image
                                aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com
                                aws ecr describe-images --repository-name ${dest_aws_repo} --region ${dest_region}  > image_tag.txt
                                if grep -w $image image_tag.txt; 
                                then 
                                    export date=$(date +%Y_%m_%d-%H%M)
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman pull ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                    podman tag ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    aws ecr batch-delete-image --repository-name ${dest_aws_repo} --image-ids imageTag=$image
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                else
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image        
                                    podman image prune --all --force
                                fi     
                            '''
                        }
                    }
                }
            }
        }          
        stage('Pull and Push SysAdmin image') {
            script {
                if (params.Components.contains('SysAdmin')) {
                    container('sch-code-builder'){
                        withAWS(role:env.ecr_role, roleAccount:env.source_aws_account, region:env.src_region) { 
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)    
                                image=$sys_tag
                                aws ecr get-login-password --region ${src_region} | podman login --username AWS --password-stdin ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com
                                podman pull ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:$image  
                                podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image} ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new  
                            '''
                        }
                        withAWS(role:env.ecr_role, roleAccount:env.dest_aws_account, region:env.dest_region) {  
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)
                                image=$sys_tag
                                aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com
                                aws ecr describe-images --repository-name ${dest_aws_repo} --region ${dest_region}  > image_tag.txt
                                if grep -w $image image_tag.txt; 
                                then 
                                    export date=$(date +%Y_%m_%d-%H%M)
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman pull ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                    podman tag ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    aws ecr batch-delete-image --repository-name ${dest_aws_repo} --image-ids imageTag=$image
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                else
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image        
                                    podman image prune --all --force
                                fi     
                            '''
                        }
                    }
                }
            }
        }
        stage('Pull and Push StudyAdmin image') {
            script {
                if (params.Components.contains('StudyAdmin')) {
                    container('sch-code-builder'){
                    // Stage 1: Pull Docker image using AWS credentials
                        withAWS(role:env.ecr_role, roleAccount:env.source_aws_account, region:env.src_region) { 
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)    
                                image=$study_tag
                                aws ecr get-login-password --region ${src_region} | podman login --username AWS --password-stdin ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com
                                podman pull ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:$image  
                                podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image} ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new  
                            '''
                        }
                        withAWS(role:env.ecr_role, roleAccount:env.dest_aws_account, region:env.dest_region) {  
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)
                                image=$study_tag
                                aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com
                                aws ecr describe-images --repository-name ${dest_aws_repo} --region ${dest_region}  > image_tag.txt
                                if grep -w $image image_tag.txt; 
                                then 
                                    export date=$(date +%Y_%m_%d-%H%M)
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman pull ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                    podman tag ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    aws ecr batch-delete-image --repository-name ${dest_aws_repo} --image-ids imageTag=$image
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                else
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image        
                                    podman image prune --all --force
                                fi     
                            '''
                        }
                    }
                }
            }
        }
        stage('Pull and Push Python image') {
            script {
                if (params.Components.contains('Python')) {
                    container('sch-code-builder'){
                    // Stage 1: Pull Docker image using AWS credentials
                        withAWS(role:env.ecr_role, roleAccount:env.source_aws_account, region:env.src_region) { 
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)    
                                image=$python_image
                                aws ecr get-login-password --region ${src_region} | podman login --username AWS --password-stdin ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com
                                podman pull ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:$image  
                                podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image} ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new  
                            '''
                        }
                        withAWS(role:env.ecr_role, roleAccount:env.dest_aws_account, region:env.dest_region) {  
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)
                                image=$python_image
                                aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com
                                aws ecr describe-images --repository-name ${dest_aws_repo} --region ${dest_region}  > image_tag.txt
                                if grep -w $image image_tag.txt; 
                                then 
                                    export date=$(date +%Y_%m_%d-%H%M)
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman pull ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                    podman tag ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    aws ecr batch-delete-image --repository-name ${dest_aws_repo} --image-ids imageTag=$image
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                else
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image        
                                    podman image prune --all --force
                                fi     
                            '''
                        }   
                    }
                }
            }
        }
        stage('Pull and Push PySpark image') {
            script {
                if (params.Components.contains('Pyspark')) {
                    container('sch-code-builder'){
                    // Stage 1: Pull Docker image using AWS credentials
                        withAWS(role:env.ecr_role, roleAccount:env.source_aws_account, region:env.src_region) { 
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)    
                                image=$pyspark_image
                                aws ecr get-login-password --region ${src_region} | podman login --username AWS --password-stdin ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com
                                podman pull ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:$image  
                                podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image} ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new  
                            '''
                        }
                        withAWS(role:env.ecr_role, roleAccount:env.dest_aws_account, region:env.dest_region) {  
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)
                                image=$pyspark_image
                                aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com
                                aws ecr describe-images --repository-name ${dest_aws_repo} --region ${dest_region}  > image_tag.txt
                                if grep -w $image image_tag.txt; 
                                then 
                                    export date=$(date +%Y_%m_%d-%H%M)
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman pull ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                    podman tag ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    aws ecr batch-delete-image --repository-name ${dest_aws_repo} --image-ids imageTag=$image
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                else
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image        
                                    podman image prune --all --force
                                fi     
                            '''
                        }
                    }
                }
            }
        }      
        stage('Pull and Push Gateway image') {
            script {
                if (params.Components.contains('PdaGateway')) {
                    container('sch-code-builder'){
                    // Stage 1: Pull Docker image using AWS credentials
                        withAWS(role:env.ecr_role, roleAccount:env.source_aws_account, region:env.src_region) { 
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)    
                                image=$gateway_tag
                                aws ecr get-login-password --region ${src_region} | podman login --username AWS --password-stdin ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com
                                podman pull ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:$image  
                                podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image} ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new  
                            '''
                        }
                        withAWS(role:env.ecr_role, roleAccount:env.dest_aws_account, region:env.dest_region) {  
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)
                                image=$gateway_tag
                                aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com
                                aws ecr describe-images --repository-name ${dest_aws_repo} --region ${dest_region}  > image_tag.txt
                                if grep -w $image image_tag.txt; 
                                then 
                                    export date=$(date +%Y_%m_%d-%H%M)
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman pull ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                    podman tag ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    aws ecr batch-delete-image --repository-name ${dest_aws_repo} --image-ids imageTag=$image
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                else
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image        
                                    podman image prune --all --force
                                fi     
                            '''
                        }
                    }
                }
            }
        }
        stage('Pull and Push Transform image') {
            script {
                if (params.Components.contains('Transform')) {
                    container('sch-code-builder'){
                    // Stage 1: Pull Docker image using AWS credentials
                        withAWS(role:env.ecr_role, roleAccount:env.source_aws_account, region:env.src_region) { 
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)    
                                image=$sch_unified_cm
                                aws ecr get-login-password --region ${src_region} | podman login --username AWS --password-stdin ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com
                                podman pull ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:$image  
                                podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image} ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new  
                            '''
                        }
                        withAWS(role:env.ecr_role, roleAccount:env.dest_aws_account, region:env.dest_region) {  
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)
                                image=$sch_unified_cm
                                aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com
                                aws ecr describe-images --repository-name ${dest_aws_repo} --region ${dest_region}  > image_tag.txt
                                if grep -w $image image_tag.txt; 
                                then 
                                    export date=$(date +%Y_%m_%d-%H%M)
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman pull ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                    podman tag ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    aws ecr batch-delete-image --repository-name ${dest_aws_repo} --image-ids imageTag=$image
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                else
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image        
                                    podman image prune --all --force
                                fi     
                            '''
                        } 
                    }
                }
            }
        }  
        stage('Pull and Push TransformApi image') {
            script {
                if (params.Components.contains('TransformApi')) {
                    container('sch-code-builder'){
                    // Stage 1: Pull Docker image using AWS credentials
                        withAWS(role:env.ecr_role, roleAccount:env.source_aws_account, region:env.src_region) { 
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)    
                                image=$map_preview
                                aws ecr get-login-password --region ${src_region} | podman login --username AWS --password-stdin ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com
                                podman pull ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:$image  
                                podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image} ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new  
                            '''
                        }
                        withAWS(role:env.ecr_role, roleAccount:env.dest_aws_account, region:env.dest_region) {  
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)
                                image=$map_preview
                                aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com
                                aws ecr describe-images --repository-name ${dest_aws_repo} --region ${dest_region}  > image_tag.txt
                                if grep -w $image image_tag.txt; 
                                then 
                                    export date=$(date +%Y_%m_%d-%H%M)
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman pull ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                    podman tag ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    aws ecr batch-delete-image --repository-name ${dest_aws_repo} --image-ids imageTag=$image
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                else
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image        
                                    podman image prune --all --force
                                fi     
                            '''
                        }    
                    }
                }
            }
        }
        stage('Pull and Push RawThirdParty image') {
            script {
                if (params.Components.contains('RawThirdParty')) {
                    container('sch-code-builder'){
                    // Stage 1: Pull Docker image using AWS credentials
                        withAWS(role:env.ecr_role, roleAccount:env.source_aws_account, region:env.src_region) { 
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)    
                                image=$raw_thirdparty_tag
                                aws ecr get-login-password --region ${src_region} | podman login --username AWS --password-stdin ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com
                                podman pull ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:$image  
                                podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image} ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new  
                            '''
                        }
                        withAWS(role:env.ecr_role, roleAccount:env.dest_aws_account, region:env.dest_region) {  
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)
                                image=$raw_thirdparty_tag
                                aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com
                                aws ecr describe-images --repository-name ${dest_aws_repo} --region ${dest_region}  > image_tag.txt
                                if grep -w $image image_tag.txt; 
                                then 
                                    export date=$(date +%Y_%m_%d-%H%M)
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman pull ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                    podman tag ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    aws ecr batch-delete-image --repository-name ${dest_aws_repo} --image-ids imageTag=$image
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                else
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image        
                                    podman image prune --all --force
                                fi     
                            '''
                        }   
                    }
                }
            }
        }  
        stage('Pull and Push PdaDB image') {
            script {
                if (params.Components.contains('PdaDb')) {
                    container('sch-code-builder'){
                    // Stage 1: Pull Docker image using AWS credentials
                        withAWS(role:env.ecr_role, roleAccount:env.source_aws_account, region:env.src_region) { 
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)    
                                image=$db_admin
                                aws ecr get-login-password --region ${src_region} | podman login --username AWS --password-stdin ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com
                                podman pull ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:$image  
                                podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image} ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new  
                            '''
                        }
                        withAWS(role:env.ecr_role, roleAccount:env.dest_aws_account, region:env.dest_region) {  
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)
                                image=$db_admin
                                aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com
                                aws ecr describe-images --repository-name ${dest_aws_repo} --region ${dest_region}  > image_tag.txt
                                if grep -w $image image_tag.txt; 
                                then 
                                    export date=$(date +%Y_%m_%d-%H%M)
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman pull ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                    podman tag ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    aws ecr batch-delete-image --repository-name ${dest_aws_repo} --image-ids imageTag=$image
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                else
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image        
                                    podman image prune --all --force
                                fi     
                            '''
                        }
                    }
                }
            }
        }  
        stage('Pull and Push DQ image') {
            script {
                if (params.Components.contains('DQ')) {
                    container('sch-code-builder'){
                    // Stage 1: Pull Docker image using AWS credentials
                        withAWS(role:env.ecr_role, roleAccount:env.source_aws_account, region:env.src_region) { 
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)    
                                image=$dq
                                aws ecr get-login-password --region ${src_region} | podman login --username AWS --password-stdin ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com
                                podman pull ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:$image  
                                podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image} ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new  
                            '''
                        }
                        withAWS(role:env.ecr_role, roleAccount:env.dest_aws_account, region:env.dest_region) {  
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)
                                image=$dq
                                aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com
                                aws ecr describe-images --repository-name ${dest_aws_repo} --region ${dest_region}  > image_tag.txt
                                if grep -w $image image_tag.txt; 
                                then 
                                    export date=$(date +%Y_%m_%d-%H%M)
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman pull ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                    podman tag ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    aws ecr batch-delete-image --repository-name ${dest_aws_repo} --image-ids imageTag=$image
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                else
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image        
                                    podman image prune --all --force
                                fi     
                            '''
                        }
                    }
                }
            }
        }  
        stage('Pull and Push PdaHome image') {
            script {
                if (params.Components.contains('PdaHome')) {
                    container('sch-code-builder'){
                    // Stage 1: Pull Docker image using AWS credentials
                        withAWS(role:env.ecr_role, roleAccount:env.source_aws_account, region:env.src_region) { 
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)    
                                image=$home
                                aws ecr get-login-password --region ${src_region} | podman login --username AWS --password-stdin ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com
                                podman pull ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:$image  
                                podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image} ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new  
                            '''
                        }
                        withAWS(role:env.ecr_role, roleAccount:env.dest_aws_account, region:env.dest_region) {  
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)
                                image=$home
                                aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com
                                aws ecr describe-images --repository-name ${dest_aws_repo} --region ${dest_region}  > image_tag.txt
                                if grep -w $image image_tag.txt; 
                                then 
                                    export date=$(date +%Y_%m_%d-%H%M)
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman pull ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                    podman tag ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    aws ecr batch-delete-image --repository-name ${dest_aws_repo} --image-ids imageTag=$image
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                else
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image        
                                    podman image prune --all --force
                                fi     
                            '''
                        }    
                    }
                }
            }
        }
        stage('Pull and Push PdaNotifications image') {
            script {
                if (params.Components.contains('PdaNotifications')) {
                    container('sch-code-builder'){
                    // Stage 1: Pull Docker image using AWS credentials
                        withAWS(role:env.ecr_role, roleAccount:env.source_aws_account, region:env.src_region) { 
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)    
                                image=$notification
                                aws ecr get-login-password --region ${src_region} | podman login --username AWS --password-stdin ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com
                                podman pull ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:$image  
                                podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image} ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new  
                            '''
                        }
                        withAWS(role:env.ecr_role, roleAccount:env.dest_aws_account, region:env.dest_region) {  
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)
                                image=$notification
                                aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com
                                aws ecr describe-images --repository-name ${dest_aws_repo} --region ${dest_region}  > image_tag.txt
                                if grep -w $image image_tag.txt; 
                                then 
                                    export date=$(date +%Y_%m_%d-%H%M)
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman pull ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                    podman tag ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    aws ecr batch-delete-image --repository-name ${dest_aws_repo} --image-ids imageTag=$image
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                else
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image        
                                    podman image prune --all --force
                                fi     
                            '''
                        }
                    }
                }
            }
        }
        stage('Pull and Push StudyTransform image') {
            script {
                if (params.Components.contains('StudyTransform')) {
                    container('sch-code-builder'){
                    // Stage 1: Pull Docker image using AWS credentials
                        withAWS(role:env.ecr_role, roleAccount:env.source_aws_account, region:env.src_region) { 
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)    
                                image=$transform
                                aws ecr get-login-password --region ${src_region} | podman login --username AWS --password-stdin ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com
                                podman pull ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:$image  
                                podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image} ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new  
                            '''
                        }
                        withAWS(role:env.ecr_role, roleAccount:env.dest_aws_account, region:env.dest_region) {  
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)
                                image=$transform
                                aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com
                                aws ecr describe-images --repository-name ${dest_aws_repo} --region ${dest_region}  > image_tag.txt
                                if grep -w $image image_tag.txt; 
                                then 
                                    export date=$(date +%Y_%m_%d-%H%M)
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman pull ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                    podman tag ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    aws ecr batch-delete-image --repository-name ${dest_aws_repo} --image-ids imageTag=$image
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                else
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image        
                                    podman image prune --all --force
                                fi     
                            '''
                        }
                    }
                }
            }
        }
        stage('Pull and Push Scale image') {
            script {
                if (params.Components.contains('Scale')) {
                    container('sch-code-builder'){
                    // Stage 1: Pull Docker image using AWS credentials
                        withAWS(role:env.ecr_role, roleAccount:env.source_aws_account, region:env.src_region) { 
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)    
                                image=$dynamicdag
                                aws ecr get-login-password --region ${src_region} | podman login --username AWS --password-stdin ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com
                                podman pull ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:$image  
                                podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image} ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new  
                            '''
                        }
                        withAWS(role:env.ecr_role, roleAccount:env.dest_aws_account, region:env.dest_region) {  
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)
                                image=$dynamicdag
                                aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com
                                aws ecr describe-images --repository-name ${dest_aws_repo} --region ${dest_region}  > image_tag.txt
                                if grep -w $image image_tag.txt; 
                                then 
                                    export date=$(date +%Y_%m_%d-%H%M)
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman pull ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                    podman tag ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    aws ecr batch-delete-image --repository-name ${dest_aws_repo} --image-ids imageTag=$image
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                else
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image        
                                    podman image prune --all --force
                                fi     
                            '''
                        }  
                    }
                }
            }
        }
        stage('Pull and Push Automaps Inference image') {
            script {
                if (params.Components.contains('Automaps-Inference-Image') && currentBuild.resultIsBetterOrEqualTo('SUCCESS')) {
                    container('sch-code-builder'){
                    // Stage 1: Pull Docker image using AWS credentials
                        withAWS(role:env.ecr_role, roleAccount:env.source_aws_account, region:env.src_region) { 
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)    
                                image=$automap_inference_image
                                aws ecr get-login-password --region ${src_region} | podman login --username AWS --password-stdin ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com
                                podman pull ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:$image  
                                podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image} ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new  
                            '''
                        }
                        withAWS(role:env.ecr_role, roleAccount:env.dest_aws_account, region:env.dest_region) {  
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)
                                image=$automap_inference_image
                                aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com
                                aws ecr describe-images --repository-name ${dest_aws_repo} --region ${dest_region}  > image_tag.txt
                                if grep -w $image image_tag.txt; 
                                then 
                                    export date=$(date +%Y_%m_%d-%H%M)
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman pull ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                    podman tag ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    aws ecr batch-delete-image --repository-name ${dest_aws_repo} --image-ids imageTag=$image
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                else
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image        
                                    podman image prune --all --force
                                fi     
                            '''
                        }
                    }
                }
            }
        }
        stage('Pull and Push OutBound image') {
            script {
                if (params.Components.contains('Outbound')) {
                    container('sch-code-builder'){
                    // Stage 1: Pull Docker image using AWS credentials
                        withAWS(role:env.ecr_role, roleAccount:env.source_aws_account, region:env.src_region) { 
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)    
                                image=$outbound_tag
                                aws ecr get-login-password --region ${src_region} | podman login --username AWS --password-stdin ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com
                                podman pull ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:$image  
                                podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image} ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new  
                            '''
                        }
                        withAWS(role:env.ecr_role, roleAccount:env.dest_aws_account, region:env.dest_region) {  
                            sh '''
                                cat uploaded_file.txt
                                export $(cat uploaded_file.txt)
                                image=$outbound_tag
                                aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com
                                aws ecr describe-images --repository-name ${dest_aws_repo} --region ${dest_region}  > image_tag.txt
                                if grep -w $image image_tag.txt; 
                                then 
                                    export date=$(date +%Y_%m_%d-%H%M)
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman pull ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                    podman tag ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:${image}-backup-${date}
                                    aws ecr batch-delete-image --repository-name ${dest_aws_repo} --image-ids imageTag=$image
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image
                                else
                                    podman tag ${source_aws_account}.dkr.ecr.${src_region}.amazonaws.com/${source_aws_repo}:${image}-new ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image  
                                    aws ecr get-login-password --region ${dest_region} | podman login --username AWS --password-stdin ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com   
                                    podman push ${dest_aws_account}.dkr.ecr.${dest_region}.amazonaws.com/${dest_aws_repo}:$image        
                                    podman image prune --all --force
                                fi     
                            '''
                        }
                    }
                }
            }
        }
        stage('Terragrunt Apply') {
            container('terragrunt-build'){
                if (params.Components.contains('TerragruntApply')) {
                    script {
                        withCredentials([string(credentialsId: 'comprehend-bot-github-token', variable: 'git_token'),                    
                            [
                            $class: 'SSHUserPrivateKeyBinding',
                            credentialsId: "jenkins_github_ssh_key",
                            usernameVariable: "username",
                            keyFileVariable: "ssh_key",
                            passphraseVariable: "passphrase",
                        ]]) {
                            withAWS(role:env.terragrunt_role, roleAccount:env.dest_aws_account, region:env.dest_region) { 
                                sh '''
                                                    
                                    mkdir ~/.ssh
                                                    ssh-keyscan github.com >> ~/.ssh/known_hosts
                                                    chmod 600 $ssh_key
                                                    echo "IdentityFile $ssh_key" > ~/.ssh/config                
                                    ls -lah
                                    if [ -d "sch-tf-envs" ]; then
                                        rm -rf sch-tf-envs
                                    fi
                                    cat uploaded_file.txt
                                    set +x
                                    export $(cat uploaded_file.txt)
                                    set -x 
                                    git clone --branch $sch_tf_envs_branch https://$git_user:$git_token@github.com/comprehend/sch-tf-envs.git
                                    ls -lah
                                    cd $vars_location

                                    aws sts get-caller-identity
                                    aws eks update-kubeconfig --name $cluster_name --region $dest_region
                                    kubectl get ns


                                    if [ -z "$api_db" ]; then
                                    echo "Warning####api_db is not provided..So taking the input of current pod image####"
                                    TF_VAR_api_db=$(kubectl describe deployment ${master_namespace}-api-db-deployment -n  ${master_namespace} | grep Image | awk '{print $2}' | awk -F':' '{print $2}')
                                    echo "The api_db is ${TF_VAR_api_db}"
                                    else
                                    export TF_VAR_api_db=${api_db}
                                    echo "Got the input.The api_db is ${TF_VAR_api_db}"
                                    fi

                                    if [ -z "$docs" ]; then
                                    echo "Warning####docs is not provided..So taking the input of current pod image####"
                                    TF_VAR_docs=$(kubectl describe deployment ${master_namespace}-docs-deployment -n  ${master_namespace} | grep Image | awk '{print $2}' | awk -F':' '{print $2}')
                                    echo "The docs is ${TF_VAR_docs}"
                                    else
                                    export TF_VAR_docs=${docs}
                                    echo "Got the input.The docs is ${TF_VAR_docs}"
                                    fi

                                    if [ -z "$redis" ]; then
                                    echo "Warning####redis is not provided..So taking the input of current pod image####"
                                    TF_VAR_redis=$(kubectl describe deployment ${master_namespace}-redis-deployment -n  ${master_namespace} | grep Image | awk '{print $2}' | awk -F':' '{print $2}')
                                    echo "The redis is ${TF_VAR_redis}"
                                    else
                                    export TF_VAR_redis=${redis}
                                    echo "Got the input.The redis is ${TF_VAR_redis}"
                                    fi

                                    if [ -z "$sys_tag" ]; then
                                    echo "Warning####sys_tag is not provided..So taking the input of current pod image####"
                                    TF_VAR_sys_tag=$(kubectl describe deployment ${master_namespace}-sys-deployment -n  ${master_namespace} | grep Image | awk '{print $2}' | awk -F':' '{print $2}')
                                    echo "The Sys_admin tag is ${TF_VAR_sys_tag}"
                                    else
                                    export TF_VAR_sys_tag=${sys_tag}
                                    echo "Got the input.The Sys_admin tag is ${TF_VAR_sys_tag}"
                                    fi

                                    if [ -z "$study_tag" ]; then
                                    echo "Warning####study_tag is not provided..So taking the input of current pod image####"
                                    TF_VAR_study_tag=$(kubectl describe deployment ${master_namespace}-study-deployment -n  ${master_namespace} | grep Image | awk '{print $2}' | awk -F':' '{print $2}')
                                    echo "The study_tag is ${TF_VAR_study_tag}"
                                    else
                                    export TF_VAR_study_tag=${study_tag}
                                    echo "Got the input.The study_tag is ${TF_VAR_study_tag}"
                                    fi

                                    if [ -z "$python_image" ]; then
                                    echo "Warning####python_image is not provided..So taking the input of current pod image####"
                                    TF_VAR_python_image=$(kubectl describe deployment ${master_namespace}-xpt-deployment -n  ${master_namespace} | grep Image | awk '{print $2}' | awk -F':' '{print $2}')
                                    TF_VAR_fga_tag=$(kubectl describe deployment ${master_namespace}-xpt-deployment -n  ${master_namespace} | grep Image | awk '{print $2}' | awk -F':' '{print $2}')
                                    TF_VAR_gsdm=$(kubectl describe deployment ${master_namespace}-xpt-deployment -n  ${master_namespace} | grep Image | awk '{print $2}' | awk -F':' '{print $2}')
                                    TF_VAR_xpt=$(kubectl describe deployment ${master_namespace}-xpt-deployment -n  ${master_namespace} | grep Image | awk '{print $2}' | awk -F':' '{print $2}')
                                    TF_VAR_dq_validator=$(kubectl describe deployment ${master_namespace}-xpt-deployment -n  ${master_namespace} | grep Image | awk '{print $2}' | awk -F':' '{print $2}')

                                    echo "The python_image is ${TF_VAR_python_image}"
                                    else
                                    export TF_VAR_python_image=${python_image}
                                    export TF_VAR_fga_tag=${python_image}
                                    export TF_VAR_gsdm=${python_image}
                                    export TF_VAR_xpt=${python_image}
                                    export TF_VAR_dq_validator=${python_image}
                                    
                                    echo "Got the input.The python_image is ${TF_VAR_python_image}"
                                    fi

                                    if [ -z "$pyspark_image" ]; then
                                    echo "Warning####pyspark_image is not provided..So taking the input of current pod image####"
                                    TF_VAR_pyspark_image=$(kubectl describe deployment ${master_namespace}-dq-validator-deployment -n  ${master_namespace} | grep Image | awk '{print $2}' | awk -F':' '{print $2}')
                                    echo "The pyspark_image is ${TF_VAR_pyspark_image}"
                                    else
                                    export TF_VAR_pyspark_image=${pyspark_image}
                                    echo "Got the input.The pyspark_image is ${TF_VAR_pyspark_image}"
                                    fi

                                    if [ -z "$gateway_tag" ]; then
                                    echo "Warning####gateway_tag is not provided..So taking the input of current pod image####"
                                    TF_VAR_gateway_tag=$(kubectl describe deployment ${master_namespace}-gateway-deployment -n  ${master_namespace} | grep Image | awk '{print $2}' | awk -F':' '{print $2}')
                                    echo "The gateway_tag is ${TF_VAR_gateway_tag}"
                                    else
                                    export TF_VAR_gateway_tag=${gateway_tag}
                                    echo "Got the input.The gateway_tag is ${TF_VAR_gateway_tag}"
                                    fi

                                    if [ -z "$sch_unified_cm" ]; then
                                    echo "Warning####sch_unified_cm is not provided..So taking the input of current pod image####"
                                    TF_VAR_sch_unified_cm=$(kubectl get configmap ${master_namespace}-study-config -o jsonpath='{.data.application\\.properties}' --namespace=${master_namespace} | grep 'pda.image.transform' | awk -F '=' '{print $2}')
                                    echo "The sch_unified_cm is ${TF_VAR_sch_unified_cm}"
                                    else
                                    export TF_VAR_sch_unified_cm=${sch_unified_cm}
                                    echo "Got the input.The sch_unified_cm is ${TF_VAR_sch_unified_cm}"
                                    fi

                                    if [ -z "$map_preview" ]; then
                                    echo "Warning####map_preview is not provided..So taking the input of current pod image####"
                                    TF_VAR_map_preview=$(kubectl describe deployment ${master_namespace}-map-preview-deployment -n  ${master_namespace} | grep Image | grep merge | awk '{print $2}' | awk -F':' '{print $2}') 
                                    echo "The map_preview is ${TF_VAR_map_preview}"
                                    else
                                    export TF_VAR_map_preview=${map_preview}
                                    echo "Got the input.The map_preview is ${TF_VAR_map_preview}"
                                    fi


                                    if [ -z "$raw_thirdparty_tag" ]; then
                                    echo "Warning####raw_thirdparty_tag is not provided..So taking the input of current pod image####"
                                    TF_VAR_raw_thirdparty_tag=$(kubectl get configmap ${master_namespace}-study-config -o jsonpath='{.data.application\\.properties}' --namespace=${master_namespace} | grep 'pda.image.raw.thirdparty' | awk -F '=' '{print $2}')
                                    TF_VAR_raw_thirdparty=$(kubectl get configmap ${master_namespace}-study-config -o jsonpath='{.data.application\\.properties}' --namespace=${master_namespace} | grep 'pda.image.raw.thirdparty' | awk -F '=' '{print $2}')
                                    echo "The raw_thirdparty_tag is ${TF_VAR_raw_thirdparty_tag}"
                                    else
                                    export TF_VAR_raw_thirdparty_tag=${raw_thirdparty_tag}
                                    export TF_VAR_raw_thirdparty=${raw_thirdparty_tag}
                                    echo "Got the input.The raw_thirdparty_tag is ${TF_VAR_raw_thirdparty_tag}"
                                    fi

                                    if [ -z "$db_admin" ]; then
                                    echo "Warning####db_admin is not provided..So taking the input of current pod image####"
                                    TF_VAR_db_admin=$(kubectl describe deployment ${master_namespace}-db-deployment -n  ${master_namespace} | grep Image | awk '{print $2}' | awk -F':' '{print $2}')
                                    echo "The db_admin is ${TF_VAR_db_admin}"
                                    else
                                    export TF_VAR_db_admin=${db_admin}
                                    echo "Got the input.The db_admin is ${TF_VAR_db_admin}"
                                    fi

                                    if [ -z "$dq" ]; then
                                    echo "Warning####dq is not provided..So taking the input of current pod image####"
                                    TF_VAR_dq=$(kubectl describe deployment ${master_namespace}-dq-deployment -n  ${master_namespace} | grep Image | awk '{print $2}' | awk -F':' '{print $2}')
                                    echo "The dq is ${TF_VAR_dq}"
                                    else
                                    export TF_VAR_dq=${dq}
                                    echo "Got the input.The dq is ${TF_VAR_dq}"
                                    fi

                                    if [ -z "$home" ]; then
                                    echo "Warning####home is not provided..So taking the input of current pod image####"
                                    TF_VAR_home=$(kubectl describe deployment ${master_namespace}-home-deployment -n  ${master_namespace} | grep Image | awk '{print $2}' | awk -F':' '{print $2}')
                                    echo "The home is ${TF_VAR_home}"
                                    else
                                    export TF_VAR_home=${home}
                                    echo "Got the input.The home is ${TF_VAR_home}"
                                    fi

                                    if [ -z "$notification" ]; then
                                    echo "Warning####notification is not provided..So taking the input of current pod image####"
                                    TF_VAR_notification=$(kubectl describe deployment ${master_namespace}-notification-deployment -n  ${master_namespace} | grep Image | awk '{print $2}' | awk -F':' '{print $2}')
                                    echo "The notification is ${TF_VAR_notification}"
                                    else
                                    export TF_VAR_notification=${notification}
                                    echo "Got the input.The notification is ${TF_VAR_notification}"
                                    fi

                                    if [ -z "$transform" ]; then
                                    echo "Warning####transform is not provided..So taking the input of current pod image####"
                                    TF_VAR_transform=$(kubectl describe deployment ${master_namespace}-transform-deployment -n  ${master_namespace} | grep Image | awk '{print $2}' | awk -F':' '{print $2}')
                                    echo "The transform is ${TF_VAR_transform}"
                                    else
                                    export TF_VAR_transform=${transform}
                                    echo "Got the input.The transform is ${TF_VAR_transform}"
                                    fi

                                    if [ -z "$dynamicdag" ]; then
                                    echo "Warning####dynamicdag is not provided..So taking the input of current pod image####"
                                    TF_VAR_dynamicdag=$(kubectl describe deployment ${master_namespace}-dynamic-dag-deployment -n  ${master_namespace} | grep Image | awk '{print $2}' | awk -F':' '{print $2}')
                                    echo "The dynamicdag is ${TF_VAR_dynamicdag}"
                                    else
                                    export TF_VAR_dynamicdag=${dynamicdag}
                                    echo "Got the input.The dynamicdag is ${TF_VAR_dynamicdag}"
                                    fi

                                    if [ -z "$automap_inference_image" ]; then
                                    echo "Warning####automap_inference_image is not provided..So taking the input of current pod image####"
                                    TF_VAR_automap_inference_image=$(kubectl get configmap ${master_namespace}-study-config -o jsonpath='{.data.application\\.properties}' --namespace=${master_namespace} | grep 'automaps_inference_image' | awk -F '=' '{print $2}')
                                    TF_VAR_automap_inference_image=$(kubectl get configmap ${master_namespace}-study-config -o jsonpath='{.data.application\\.properties}' --namespace=${master_namespace} | grep 'automaps_inference_image' | awk -F '=' '{print $2}')
                                    echo "The automap_inference_image is ${TF_VAR_automap_inference_image}"
                                    else
                                    export TF_VAR_automap_inference_image=${automap_inference_image}
                                    export TF_VAR_automap_inference_image=${automap_inference_image}
                                    echo "Got the input.The automap_inference_image is ${TF_VAR_automap_inference_image}"
                                    fi

                                    if [ -z "$outbound_tag" ]; then
                                    echo "Warning####outbound image is not provided..So taking the input of current pod image####"
                                    TF_VAR_outbound_image=$(kubectl describe deployment ${master_namespace}-outbound-deployment -n  ${master_namespace} | grep Image | awk '{print $2}' | awk -F':' '{print $2}')
                                    echo "The outbound image is ${TF_VAR_outbound_image}"
                                    else
                                    export TF_VAR_outbound_image=${outbound_tag}
                                    echo "Got the input.The outbound image is ${TF_VAR_outbound_image}"
                                    fi



                                    terragrunt run-all apply --terragrunt-non-interactive --auto-approve --terragrunt-include-dir datahub-master-sit5 --terragrunt-exclude-dir datahub-account-sit5 --terragrunt-exclude-dir datahub-account-sit5-uat --terragrunt-exclude-dir sit5-dh-master --terragrunt-exclude-dir sit5-dh-accounts --terragrunt-exclude-dir foundation --terragrunt-exclude-dir eks --terragrunt-exclude-dir eks-infra --terragrunt-exclude-dir kafka --terragrunt-exclude-dir s3 --terragrunt-exclude-dir zookeeper --terragrunt-exclude-dir airflow


                                    sleep 10

                                    rm -rf ~/.ssh 
                                    rm -rf sch-tf-envs

                                '''
                            }
                        }
                    }
                }
            }
        }
        stage('Terragrunt Tenant Apply') {
            container('terragrunt-build'){
                if (params.Components.contains('Terragrunt-Tenant-Apply')) {
                    script {
                        withAWS(role:env.terragrunt_role, roleAccount:env.dest_aws_account, region:env.dest_region) { 
                            withCredentials([string(credentialsId: 'comprehend-bot-github-token', variable: 'git_token'),
                            [
                                $class: 'SSHUserPrivateKeyBinding',
                                credentialsId: "jenkins_github_ssh_key",
                                usernameVariable: "username",
                                keyFileVariable: "ssh_key",
                                passphraseVariable: "passphrase",
                            ]]) {
                                sh '''
                                                
                                    mkdir ~/.ssh

                                    ssh-keyscan github.com >> ~/.ssh/known_hosts
                                    chmod 600 $ssh_key
                                    echo "IdentityFile $ssh_key" > ~/.ssh/config                
                                    
                                    ls -lah
                                    if [ -d "sch-tf-envs" ]; then
                                        rm -rf sch-tf-envs
                                    fi
                                    cat uploaded_file.txt
                                    set +x
                                    export $(cat uploaded_file.txt)
                                    set -x 
                                    git clone --branch $sch_tf_envs_branch https://$git_user:$git_token@github.com/comprehend/sch-tf-envs.git
                                    ls -lah
                                    cd $vars_location
                                    aws sts get-caller-identity
                                    aws eks update-kubeconfig --name $cluster_name --region $dest_region
                                    kubectl get ns

                                    terragrunt run-all plan --terragrunt-include-dir datahub-account-sit5 --terragrunt-include-dir datahub-account-sit5-uat --terragrunt-exclude-dir datahub-master-sit5 --terragrunt-exclude-dir sit5-dh-master --terragrunt-exclude-dir sit5-dh-accounts --terragrunt-exclude-dir foundation --terragrunt-exclude-dir eks --terragrunt-exclude-dir eks-infra --terragrunt-exclude-dir kafka --terragrunt-exclude-dir s3 --terragrunt-exclude-dir zookeeper --terragrunt-exclude-dir airflow 
                                    sleep 10



                                '''
                            }
                        }
                    }
                }
            }
        } 
        stage('RedisRestart') {
            container('sch-code-builder'){
                if (params.Components.contains('RedisRestart') && currentBuild.resultIsBetterOrEqualTo('SUCCESS')) {
                    script {
                        // Stage 2: Tag and push Docker image using different AWS credentials
                        withAWS(role:env.terragrunt_role, roleAccount:env.dest_aws_account, region:env.dest_region) { 
                            sh '''
                                aws sts get-caller-identity
                                aws eks update-kubeconfig --name $cluster_name --region $dest_region
                                kubectl rollout restart deployment ${master_namespace}-sys-deployment -n ${master_namespace}
                                sleep 5
                                kubectl rollout restart deployment ${master_namespace}-study-deployment -n ${master_namespace}
                                sleep 5
                                kubectl rollout restart deployment ${master_namespace}-redis-deployment -n ${master_namespace}
                            '''
                        }
                    }
                }
            }
        }
        stage('Global files S3 upload') {
            script {
                if (params.Components.contains('GlobalFiles') && currentBuild.resultIsBetterOrEqualTo('SUCCESS')) {
                    container('sch-code-builder') {
                    // Stage 1: Pull Docker image using AWS credentials
                    git branch: 'release-23R2', credentialsId: 'jenkins_github_access_token', url: 'https://github.com/comprehend/sch.git'
                        withAWS(role:env.terragrunt_role, roleAccount:env.dest_aws_account, region:env.dest_region) {  
                            sh '''
                                ls -lah
                                s3_bucket=$dh_s3_bucket
                                s3_folder="global/"


                                if [ -d "global" ]; then
                                # Remove the directory and its contents
                                    rm -r "global"
                                    echo "Directory 'global' has been removed."
                                    mkdir ./global
                                else
                                    echo "Directory 'global' does not exist."
                                    mkdir ./global
                                fi
                                aws s3 cp "s3://${s3_bucket}/${s3_folder}" ./global/ --recursive
                                # Navigate to the /tmp/ directory
                                # Create a zip archive
                                zip -r latest_${BUILD_TAG}.zip global

                                # Copy the zip archive to another location in S3
                                aws s3 cp latest_${BUILD_TAG}.zip "s3://${s3_bucket}/global-files-archive/"
                                aws s3 cp metadata/codm/* s3://${s3_bucket}/global/codm/latest/
                                aws s3 cp metadata/del/* s3://${s3_bucket}/global/spdm/latest/  
                                aws s3 cp metadata/standards/* s3://${s3_bucket}/global/standards/latest/
                                
                                # Remove the files from the S3 folder
                                #  aws s3 rm "s3://${s3_bucket}/${s3_folder}" --recursive
                                #rm -rf global
                                # Return to the original working directory

                                ls -lah
                                s3_bucket=$dh_uat_s3_bucket
                                s3_folder="global/"


                                if [ -d "global" ]; then
                                # Remove the directory and its contents
                                    rm -r "global"
                                    echo "Directory 'global' has been removed."
                                    mkdir ./global
                                else
                                    echo "Directory 'global' does not exist."
                                    mkdir ./global
                                fi
                                aws s3 cp "s3://${s3_bucket}/${s3_folder}" ./global/ --recursive
                                # Navigate to the /tmp/ directory
                                # Create a zip archive
                                zip -r latest_${BUILD_TAG}.zip global

                                # Copy the zip archive to another location in S3
                                aws s3 cp latest_${BUILD_TAG}.zip "s3://${s3_bucket}/global-files-archive/"
                                aws s3 cp metadata/codm/* s3://${s3_bucket}/global/codm/latest/
                                aws s3 cp metadata/del/* s3://${s3_bucket}/global/spdm/latest/  
                                aws s3 cp metadata/standards/* s3://${s3_bucket}/global/standards/latest/
                                
                                # Remove the files from the S3 folder
                                #  aws s3 rm "s3://${s3_bucket}/${s3_folder}" --recursive
                                #rm -rf global
                                # Return to the original working directory
                            '''
                        }
                    }
                }
            }
        }
        stage('OTB S3 upload') {
            script {
                if (params.Components.contains('OTB') && currentBuild.resultIsBetterOrEqualTo('SUCCESS')) {
                    container('sch-code-builder'){
                        // Stage 1: Pull Docker image using AWS credentials
                        git branch: 'test', credentialsId: 'jenkins_github_access_token', url: 'https://github.com/saamaresearch/otb.git'
                        withCredentials([string(credentialsId: 'dev5_zip_pass', variable: 'zip_pass')]) {
                            withAWS(role:env.terragrunt_role, roleAccount:env.dest_aws_account, region:env.dest_region) {  
                                sh '''
                                    zip -r -P ${zip_pass} functions.zip functions/
                                    S3_FILE_KEY="functions.zip"
                                    aws s3 cp functions.zip s3://${otb_s3_bucket}/
                                '''
                            }
                        }
                    }
                }
            }    
        }

        stage('AutoMapper') {
            if (params.Components.contains('AutoMapper'))  {
                script {
                    container('sch-automapper') {
                        withCredentials([string(credentialsId: 'comprehend-bot-github-token', variable: 'src_git_token'),string(credentialsId: 'comprehend-bot-github-token', variable: 'dest_git_token')]){
                            // Set Git user and email globally
                            sh '''
                                set +e
                                git config --global user.email lsac.sre+comprehend.bot@saama.com
                                git config --global user.name comprehend-bot
                                git clone --branch $automapper_git_src_branch https://$src_git_user:$src_git_token@github.com/saamaresearch/sam-automap-inference.git
                                git clone --branch $automapper_git_dest_branch https://$dest_git_user:$dest_git_token@github.com/comprehend/${automapper_dest_repo}.git
                                cd $automapper_dest_repo && git checkout $automapper_git_dest_branch
                                cd ..
                                if [ -d "$automapper_dest_repo/dags/" ]; then
                                    echo "dags dir exist"
                                else
                                    mkdir $automapper_dest_repo/dags/
                                fi
                                cp -r sam-automap-inference/sch_dags/* $automapper_dest_repo/dags/
                                cp -r sam-automap-inference/sch_dags/.airflowignore $automapper_dest_repo/dags/
                                cd $automapper_dest_repo/
                                git status
                                git add .
                                git commit -m "E2E deployment" .
                                git push https://$dest_git_user:$dest_git_token@github.com/comprehend/${automapper_dest_repo}.git
                                set -e
                            '''
                        }
                    }
                }
            }
        }
        stage('Git-sit3-sit5') {
            if (params.Components.contains('Git-sit3-sit5')) {
                script {
                    container('sch-automapper') {
                        withCredentials([string(credentialsId: 'vishnu-github-token', variable: 'src_git_token'),string(credentialsId: 'comprehend-bot-github-token', variable: 'dest_git_token')]){
                            // Set Git user and email globally
                            sh '''
                                set +e
                                git config --global user.email lsac.sre+comprehend.bot@saama.com
                                git config --global user.name comprehend-bot
                                git clone --branch $automapper_git_src_branch https://$src_git_user:$src_git_token@github.com/comprehend/${automapper_src_repo}.git
                                git clone --branch $automapper_git_dest_branch https://$dest_git_user:$dest_git_token@github.com/comprehend/${automapper_dest_repo}.git
                                cd $automapper_dest_repo && git checkout $automapper_git_dest_branch
                                cd ..
                                if [ -d "$automapper_dest_repo/dags/" ]; then
                                    rm -rf $automapper_dest_repo/dags/
                                    mkdir $automapper_dest_repo/dags/
                                else
                                    mkdir $automapper_dest_repo/dags/
                                fi
                                cp -r ${automapper_src_repo}/dags/* $automapper_dest_repo/dags/
                                cp -r ${automapper_src_repo}/dags/.airflowignore $automapper_dest_repo/dags/
                                cd $automapper_dest_repo/
                                git status
                                git add .
                                git commit -m "Moved dag data from sit3 to sit5" .
                                git push https://$dest_git_user:$dest_git_token@github.com/comprehend/${automapper_dest_repo}.git
                                set -e
                            '''
                        }
                    }
                }
            }    
        }
        stage('Automapper S3 Upload') {
            container('sch-code-builder'){
                if (params.Components.contains('Automaps-Inference-S3-Upload') && currentBuild.resultIsBetterOrEqualTo('SUCCESS')) {
                    script {
                        // Stage 2: Tag and push Docker image using different AWS credentials
                        withAWS(role:env.terragrunt_role, roleAccount:env.source_aws_account, region:env.src_region) { 
                            sh '''
                                mkdir AUTOMAPS_INFERENCE
                                echo ${source_automapper_s3_bucket}
                                aws s3 ls s3://${source_automapper_s3_bucket}/
                                aws s3 ls s3://${source_automapper_s3_bucket}/AUTOMAPS_INFERENCE/
                                aws s3 cp s3://${source_automapper_s3_bucket}/AUTOMAPS_INFERENCE AUTOMAPS_INFERENCE --recursive 
                                ls
                            '''
                        }        
                        withAWS(role:env.terragrunt_role, roleAccount:env.dest_aws_account, region:env.dest_region) {  
                            sh '''
                                aws sts get-caller-identity
                                echo ${dh_s3_bucket}
                                aws s3 cp AUTOMAPS_INFERENCE/ s3://${dh_s3_bucket}/AUTOMAPS_INFERENCE --recursive
                                aws s3 ls s3://${dh_s3_bucket}/
                                aws s3 ls s3://${dh_s3_bucket}/AUTOMAPS_INFERENCE/
                                ls
                                echo ${dh_uat_s3_bucket}
                                aws s3 cp AUTOMAPS_INFERENCE/ s3://${dh_uat_s3_bucket}/AUTOMAPS_INFERENCE --recursive
                                aws s3 ls s3://${dh_uat_s3_bucket}/
                                aws s3 ls s3://${dh_uat_s3_bucket}/AUTOMAPS_INFERENCE/
                                ls
                            '''
                        }
                    }
                }
            }
        }
        stage('init-all-api-Trigger'){
            container('sch-sanity-executor') {
                if (params.Components.contains('init-all-api-Trigger') && currentBuild.resultIsBetterOrEqualTo('SUCCESS')) {
                    script {
                        withCredentials([string(credentialsId: 'sch-sit5-client-secret', variable: 'client_secret'),string(credentialsId: 'comprehend-bot-github-token', variable: 'git_token')]) {
                            sh '''
                                set +x
                                if [ -d "sch-infra" ]; then
                                    rm -rf sch-infra
                                fi
                                set -x
                                git clone --branch $sch_tf_envs_branch https://$git_user:$git_token@github.com/comprehend/sch-infra.git

                                export account_name=${primary_tenant}
                                ls

                                python3 sch-infra/python/account-init-all-api-trigger.py
                            
                            '''
                        }   
                    }
                }
            }
        }
        stage('dh-sanity-checks'){
            container('sch-sanity-executor') {
                if (params.Components.contains('dh-sanity-checks') && currentBuild.resultIsBetterOrEqualTo('SUCCESS')) {
                    script {
                        withCredentials([string(credentialsId: 'sch-sit5-client-secret', variable: 'client_secret'),string(credentialsId: 'comprehend-bot-github-token', variable: 'git_token')]) {
                            sh '''
                                set +x
                                if [ -d "sch-infra" ]; then
                                    rm -rf sch-infra
                                fi
                                set -x
                                git clone --branch $sch_tf_envs_branch https://$git_user:$git_token@github.com/comprehend/sch-infra.git

                                export account_name=${primary_tenant}
                                ls
                                pwd
                                python3 sch-infra/python/sanity-checks.py
                    
                            '''
                        }
                    }
                }
            }
        }
    }   
}
